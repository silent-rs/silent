# Silent 路由匹配性能基准测试报告

## 概述

本报告展示了 Silent 框架中路由匹配功能的性能基准测试结果，特别关注10层复杂路由的匹配性能。

## 测试环境

- **框架版本**: Silent v2.5.2
- **Rust版本**: 1.88.0
- **测试平台**: macOS (darwin 24.5.0)
- **编译模式**: Release (优化模式)

## 测试场景

### 1. 基础路由测试

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| 简单路由匹配 | ~104 ns | 优秀 |
| 嵌套路由匹配 | ~155 ns | 良好 |
| 带中间件路由 | ~107 ns | 优秀 |
| 多中间件路由 | ~105 ns | 优秀 |

### 2. 复杂路由测试

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| GET /api/v1/users | ~163 ns | 良好 |
| POST /api/v1/posts | ~161 ns | 良好 |
| GET /api/v1/posts/comments | ~172 ns | 良好 |

### 3. 10层深度嵌套路由测试

#### 3.1 静态路径路由

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| 匹配最深路由 | ~233 ns | 良好 |
| 匹配中间层路由 | ~202 ns | 良好 |
| 不匹配路由 | ~235 ns | 良好 |

#### 3.2 带参数路由

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| 匹配最深路由（带参数） | ~329 ns | 良好 |
| 匹配中间层路由（带参数） | ~227 ns | 良好 |

#### 3.3 带中间件路由

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| 匹配最深路由（带中间件） | ~231 ns | 良好 |

#### 3.4 混合类型路由

| 测试场景 | 平均耗时 | 性能表现 |
|---------|---------|---------|
| 匹配最深混合路由 | ~288 ns | 良好 |
| 匹配中间层混合路由 | ~230 ns | 良好 |

### 4. 路由深度性能对比

| 路由深度 | 平均耗时 | 性能趋势 |
|---------|---------|---------|
| 3层路由 | ~171 ns | 基准 |
| 5层路由 | ~192 ns | +12% |
| 7层路由 | ~210 ns | +23% |
| 10层路由 | ~240 ns | +40% |

## 性能分析

### 1. 路由深度对性能的影响

从测试结果可以看出，路由深度对性能有一定影响，但影响相对较小：

- **3层到10层**: 性能下降约40%
- **每增加一层**: 平均增加约10-15ns
- **线性增长**: 性能下降基本呈线性关系

### 2. 参数解析的性能开销

带路径参数的路由比静态路由慢约30-40%：

- **静态路由**: ~233 ns
- **参数路由**: ~329 ns
- **性能差异**: 约41%的开销

### 3. 中间件的影响

中间件对路由匹配性能的影响很小：

- **无中间件**: ~233 ns
- **有中间件**: ~231 ns
- **性能差异**: 几乎无影响

### 4. 高负载测试

1000个连续请求的处理时间约为225μs，平均每个请求约225ns，说明在高负载下性能保持稳定。

## 优化建议

### 1. 路由设计优化

- **避免过深嵌套**: 建议路由深度不超过7层
- **合理使用参数**: 参数路由比静态路由慢，应适度使用
- **中间件优化**: 中间件对匹配性能影响很小，可以放心使用

### 2. 性能优化方向

- **路由树优化**: 可以考虑使用更高效的路由树结构
- **参数解析优化**: 参数解析是主要性能瓶颈，可以进一步优化
- **缓存机制**: 对于频繁访问的路由可以考虑添加缓存

## 结论

Silent 框架的路由匹配性能表现优秀：

1. **基础性能**: 简单路由匹配在100ns左右，性能优秀
2. **深度支持**: 10层深度路由仍能保持良好性能（~240ns）
3. **功能完整**: 支持参数、中间件等高级功能，且性能影响可控
4. **线性扩展**: 性能随路由深度线性增长，可预测性好

总体而言，Silent 的路由匹配功能在保持功能完整性的同时，提供了优秀的性能表现，适合构建复杂的Web应用。

## 如何运行基准服务（A/B/C 场景）

本仓库提供可运行的基准服务入口（`benchmark/src/main.rs`），通过环境变量选择场景。服务默认监听 `127.0.0.1:8080`，可通过 `PORT` 覆盖：

```bash
# 场景 A：GET / 返回固定 12B 文本
SCENARIO=A PORT=8080 cargo run -p benchmark --release

# 场景 B：解析 3 个路径参数 + 5 个查询参数 + 返回 JSON
SCENARIO=B PORT=8080 cargo run -p benchmark --release

# 场景 C：1KiB 静态文件（含 ETag/If-None-Match），GET /static
SCENARIO=C PORT=8080 cargo run -p benchmark --release
```

如需修改端口，使用 `PORT=<port>` 环境变量（例如 `PORT=18080`）。

### 压测示例（bombardier）

```bash
# A 场景
bombardier -c 256 -d 30s http://127.0.0.1:8080/

# B 场景（示例参数）
bombardier -c 256 -d 30s 'http://127.0.0.1:8080/b/abc/123/xyz?q1=a&q2=b&q3=42&q4=true&q5=z'

# C 场景：首次命中 200，随后带 If-None-Match 复用 304
curl -i http://127.0.0.1:8080/static
ETAG=$(curl -sI http://127.0.0.1:8080/static | awk -F': ' '/^etag:/{print $2}' | tr -d '\r')
bombardier -c 256 -d 30s -H "If-None-Match: $ETAG" http://127.0.0.1:8080/static

或使用脚本（需安装 bombardier 与 curl）：

```bash
chmod +x benchmark/scripts/run_bombardier.sh
# 运行前请在另一个终端启动服务：
#   SCENARIO=A PORT=8080 cargo run -p benchmark --release

# A 场景
SCENARIO=A PORT=8080 benchmark/scripts/run_bombardier.sh

# B 场景
SCENARIO=B PORT=8080 benchmark/scripts/run_bombardier.sh

# C 场景（脚本会自动获取 ETag 并使用 If-None-Match）
SCENARIO=C PORT=8080 benchmark/scripts/run_bombardier.sh
```
```

### 与 Axum/Actix 的对比

- 对标框架：Axum、Actix。
- 要点：
  - 固定相同硬件、相同 Rust 版本、相同编译参数（`--release`）。
  - 固定监听端口与路由语义（返回体大小、HTTP 头一致）。
  - 记录 p50/p90/p99、RPS、CPU 利用率，并保存 flamegraph（`pprof-rs`）。
  - 结果需重复 3 次，方差在可接受范围内。

> 备注：后续 PR5 将把上述流程纳入 CI，自动产出对比结果与火焰图工件。

## 测试代码

详细的测试代码请参考 `benches/route_benchmark.rs` 文件，包含了各种复杂场景的基准测试。
